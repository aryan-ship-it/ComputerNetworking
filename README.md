This README provides an overview of Object oriented TCP/IP message stack encapsulation, including its Object-oriented design principle, purpose, components, and how it works

**Purpose**

Encapsulating TCP/IP message stacks is a technique for ensuring dependable networked device communication. It divides data into tiny packets that may be sent over the network and put back together at the other end. Each packet gains headers during the encapsulation process, which contain data required for delivery and routing. This project uses the SOLID Object Oriented Design Principle which consists of Single-Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.

**Components**

Main program: The main program takes GET and POST requests through HttpRequest object request and request2 respectively. Then each of the requests is pushed into the Queue and a singleton pattern is used to handle each request at a time. While doing so the object of the previous class is encapsulated to the next object of the class.

Application layer: The application layer reads the getRequest and postRequest text and data is generated by the application. The data is passed down to the transport layer for further processing. This layer is named as HTTPRequest Class and has four private members consisting of maps, vectors, and strings. It has a public constructor which takes two strings as a parameter.

Transport layer: The transport layer encapsulate the data from the application layer and creates a source port and destination port for the data to transfer and is responsible for breaking down data into smaller packets and ensuring that they are reliably delivered. The two main protocols used at this layer are TCP and UDP. TCP protocol is used for this project as it is more reliable. This layer consists of 2 private data members and 3 private functions. The constructor of this class points to the same memory location of the HTTP request object. The private function generatePort() generates the random port numbers, and the other 2 private functions destPortGenerator() and sourcePortGenerator() use the generatePort() function to receive a randomly generated port that doesn't share the same port number.

Network layer: The Network layer encapsulate the data from the Transport layer and adds an IP header to each packet, which contains information such as the source and destination addresses. This layer is responsible for routing packets across different networks. This layer consists of 3 private data members consisting of a map that stores the key as a "Source IP" or "Destination IP" and value as an IP address and two string variables. This class has a helper class IPAddress class which generates a random IP address and stores it in a map which key-value pair. 

Data link layer: The Data link layer encapsulate the data from the Network layer and uses a MAC to generate the frames that will be transmitted. When transmitting data, this layer adds a header containing the source and destination MAC addresses to the packet received from the Network layer. This layer consists of 3 private data members a map and two strings and one private function. The private function randomDataLinkLayer() generates a random Mac Address and stores it in a map as a key-value pair.

Physical layer: The Physical layer encapsulates the data from the Data link layer and sends and receives signals on the physical wire or antenna to transmit the bits found in frames. It uses a bitset library that changes strings into binary. 

Helper Class:


IPAddress Class: This class is a helper class for the NetworkLayer class and consist of 2 private data member and 1 member function. 


Serializer Class: This class is a helper class that serializes the message, both string and binary, and appends it into a file.


PhysicalLayer Class: This consists of 3 private data members and 3 private functions

**Contributors**

aryan-ship-it

Willie1416

Asal
